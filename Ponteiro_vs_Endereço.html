<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset='UTF-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>REAA</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <link rel='stylesheet' type='text/css' media='screen' href='main.css'>
    <link rel="stylesheet" type='text/css' href="Estilo.css">

    <script src='main.js'></script>


</head>

<body>
    <div id="interface">

        <header id="cabecalho">
            <hgroup id="logo-cabecalho">
                <img src="REAA-Logo001.PNG">

            </hgroup>

            <nav id="menu">
                <ul>
                    <h2>
                        <li><a href="index.html">HOME</a></li>
                        <li><a href="conteudo.html">CONTEUDO</a></li>
                    </h2>
                </ul>
            </nav>
        </header>
        <section id="conf-aulas">
            <div id="Aulas">
                <hgroup id="saudacoes">
                    <h2>Ponteiro vs Endereço</h2>
                </hgroup>
                <br>
                <br>
                <p>
                    Ao explorar ponteiros e endereços em C++, você pode fazer várias perguntas para aprofundar seu
                    entendimento
                    È muito importante que entenda bem sobre ponteiros, pois é um recurso das linguagens de médio á
                    baixo nível
                    que permite manipular a mamória do embarcado, além de deixar o programa mais rápido e menor mantendo
                    a complexidade.
                </p>

                <p>
                <h3>Mas!Afinal...</h3>

                <h3>1 O que é um ponteiro? </h3>
                <p>
                    <font color="gray">R:Ponteiro é uma variável que armazena o endereço de outra
                        variável, deferente de uma variável que
                        aramzena um valor qualquer.</font> <br>
                </p>

                <h3>2 Como declarar um ponteiro em C++? </h3>

                <p>
                    <font color="gray">R: Segue a sintaxe abaixo <br>
                        &lt;tipo&gt; &nbsp; &#42;&lt;nome_variavel&gt;
                        <br> Ex:int *yptr;
                        <br> int &nbsp;*yptr, <br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*xptr; &nbsp;
                    </font><br>
                </p>

                <h3>3 O que é um endereço de memória? </h3>

                <p>
                    <font color="gray">R:Um endereço de memória é um identificador único atribuído a cada
                        local na memória do sistema de computador. <br>
                        Imagine que cada posição de memória é um capacitor que armazena uma carga que o sistema
                        operacinal
                        vê como sendo um byte(Devidamente é compreensível que as informações são armazenadas
                        eletricamente).
                    </font><br>
                </p>

                <h3>4 Como obter o endereço de uma variável?</h3>
                <p>
                    <font color="gray">R: Usando o &(e-comercial ou ampersand) antes da variável.<br>
                        Ex: <br>
                        <pre>
                           <code>
       #include &lt;iostream&gt;
       using namespace std;
       #include &lt;cstring&gt;
       using std::string;                 
                                   
       //========================================
       //--Declaração das funções--
                                   
       //========================================
       //--Corpo do programa--
       int main()
       {
       cout &lt;&lt; "Hello REAA" &lt;&lt; endl;
       int y=5;
       int *yptr=0;
                                   
       cout&lt;&lt;"Endereco de y na memoria: "     &lt;&lt; &y    &lt;&lt; endl;
       cout&lt;&lt;"O endereço de yptr na memoria: "&lt;&lt; &yptr  &lt;&lt; endl;
                                   
       cout&lt;&lt;endl;
       //O ponteiro aponta para o valor de y;
       yptr&nbsp;=&nbsp;&#38;y;//Aqui o ponteiro estará apontando para onde o y está.
       Tendo acesso á tudo o que o y possue, desde endereço de memória, valor e tipo.
                                   
       cout&lt;&lt;"Agora o yptr tem o endereço do y: "&lt;&lt;  yptr &lt;&lt;endl;
       cout&lt;&lt;"O ponteiro também tem acesso ao valor do y: " &lt;&lt; *yptr &lt;&lt;endl;
       cout&lt;&lt;"Mas, se eu atribuir *yptr=9:"&lt;&lt;endl;
                                   
       //depois que já apontei yptr para um endereço de variável, posso atribuir na variável aravés do ponteiro.
       *yptr=9;//atribuo 9 no y usando o ponteiro
       cout&lt;&lt;"Agora y vale: "&lt;&lt;*yptr&lt;&lt;endl;
                                   
       return 0;
       }//Fim
       //========================================
       //--Desenvolvimento das funções--
           </code>
       </pre>

                    </font>

                </p>
                <h3>5 Como atribuir um valor a um ponteiro?</h3>
                <p>
                    <font color="gray">R:Um ponteiro nunca terá um valor diferente do valor nullo(NULL) ou valor zero(
                        numero inteiro zero), apenas estará apontando para quem tem valor.
                        E através do ponteiro muda-se o valor de quem tem.
                        <br>Ex:
                        <br>int *yptr=0//Declaro um ponteiro do tipo int.
                        <br>int y=9;//Declaro valor 9 na variável y;
                        <br>*yptr=&y;//

                    </font><br>
                </p>
                <h3>6 O que é a operação de desreferenciamento (*)?</h3>
                <p>
                    <font color="gray">R:Desreferênciar um ponteiro significa acessar o conteúdo da memória para o qual
                        o
                        ponteiro aponta. <br></font>
                </p>

                <h3>7 Quais são os ponteiros nulos?</h3>
                <p>
                    <font color="gray">R: nullptr, 0 ou NULL <br></font>
                </p>

                <h3>8 O que é aritmética de ponteiros?</h3>

                <p>
                    <font color="gray">R: A aritmética de ponteiros em C++ permite realizar operações aritméticas
                        diretas em
                        ponteiros, proporcionando uma maneira eficiente de navegar por elementos em arrays ou estruturas
                        de
                        dados. As operações aritméticas de ponteiros incluem adição, subtração, incremento e decremento,
                        e
                        essas operações são baseadas no tamanho do tipo de dados ao qual o ponteiro aponta.
                        A aritmética de ponteiros é especialmente útil ao trabalhar com arrays, onde você pode
                        movimentar um
                        ponteiro pelos elementos do array de maneira eficiente. <br>
                        Ex: <br>
                        <pre>

                        <code>
    #include &lt;iostream&gt;
    using namespace std;
    #include &lt;cstring&gt;
    using std::string;
                                
    //========================================
    //--Declaração das funções--
                                
    //========================================
    //--Corpo do programa--
    int main()
    {
    cout &lt;&lt; "Hello REAA" &lt;&lt; endl;
    int Array[8]={10, 20, 30, 40, 50, 60, 70, 80};
    int *Arrayptr=nullptr;
    Arrayptr=Array;
    cout&lt;&lt;"valor:"&lt;&lt;*Arrayptr++&lt;&lt;endl;//mostra 10
    cout&lt;&lt;"valor:"&lt;&lt;*Arrayptr++&lt;&lt;endl;//mostra 20
    cout&lt;&lt;"valor:"&lt;&lt;*Arrayptr++&lt;&lt;endl;//mostra 30
    cout&lt;&lt;"valor:"&lt;&lt;*Arrayptr+4&lt;&lt;endl;//mostra 40+4
    cout&lt;&lt;"Valor:"&lt;&lt;*(Arrayptr+3)&lt;&lt;endl;//mostra o valor de 3 indices a frente do atual, nocaso 70
                                
    return 0;
    }//Fim
    </code>
    </pre>
                        <p>
                            É importante ter cautela ao usar a aritmética de ponteiros para garantir que você não
                            ultrapasse
                            os
                            limites do array ou acesse áreas inválidas da memória, o que pode levar a comportamentos
                            indefinidos. A aritmética de ponteiros é uma ferramenta poderosa, mas deve ser usada com
                            responsabilidade.
                        </p>
                    </font>
                </p>


                <h3>9 Como evitar vazamentos de memória com ponteiros?</h3>
                <p>
                    <font color="gray">R: Evitar vazamentos de memória é fundamental ao trabalhar com alocação dinâmica
                        de memória em C++. Aqui estão algumas práticas recomendadas para evitar vazamentos de memória ao
                        utilizar ponteiros: <br>
                        <b>1 Liberação de Memória Alocada Dinamicamente:</b> <br>

                        Sempre libere a memória alocada dinamicamente usando delete para objetos alocados com new. Para
                        arrays, use delete[].
                        <pre>
                    <code>
#include <iostream>
using namespace std;
     
//========================================
//--Corpo do programa--
int main()
{
cout &nbsp;&lt;&lt; "Hello REAA" &nbsp;&lt;&lt; endl;
char *vetor00 = new char[10];
int  *vetor01 = new int[10];
cout&nbsp;&lt;&lt;"char  int\n";
for(int i=0; i&lt;10; i++)
{
*vetor00 = ('A'+i);
*vetor01 = i;
cout &nbsp;&lt;&lt;*vetor00&nbsp;&lt;&lt;"   | "&lt;&lt; *vetor0&nbsp;&lt;&lt;endl;
                            
}
                            
delete[]vetor00; //Libera a memória que foi alocada;
delete[]vetor01; //Libera a memória que foi alocada;
                                
return 0;
}//Fim                           
                    </code>
                </pre>

                </p>
                </font>
                <font color="gray">
                    <h3><b>2 Inicialização e Nulidade:</b> </h3>
                    </p>
                    Inicialize os ponteiros com nullptr para garantir que não apontem para lixo de memória. Após liberar
                    a memória, defina o ponteiro como nullptr para evitar desreferenciamento acidental. <br>
                </font>

                <h3>10 O que são ponteiros para funções? </h3>
                <p>
                    <font color="gray">R: Ponteiros para funções em C++ são variáveis que armazenam endereços de
                        funções.
                        <br>
                        Ex: <br>
                        <pre>
                        <code>
    #include <iostream>
    using namespace std;
                                
    //========================================
    //--Protótipo das funcoes--
    void saudacao();
    //========================================
    //--Corpo do programa--
    int main()
    {
    cout &lt;&lt; "Hello REAA" &lt;&lt; endl;
    void (*PtrSaudacao)() = saudacao;  //(*PtrSaudacao)() é um ponteiro para uma funçao
                                
    PtrSaudacao();  //chama a função através do ponteiro.
                                
    return 0;
    }//Fim
    //========================================
    //--Dsenvolvimento das funcoes--
    void saudacao()
    {
       cout &lt;&lt; "Leia com atencao!!" &lt;&lt; endl;
                                
    }
                    </code>
                    </pre>
                    </font>
                </p>
                <h3>11 Qual a diferença entre new e malloc?</h3>
                <p>
                    <font color="gray">R: "new" e "malloc" são operadores utilizados em C++ e C, respectivamente, para
                        alocar
                        memória dinamicamente. No entanto, existem algumas diferenças importantes entre eles: <br>

                        <b>Linguagem:</b> <br>
                        new é um operador em C++, enquanto malloc é uma função da biblioteca padrão em C. <br>

                        <b>Tipo de Dados:</b> <br>
                        new é mais inteligente em termos de tipos. Ele é usado para alocar memória para objetos e chama
                        construtores para inicializar esses objetos.
                        malloc aloca uma quantidade de bytes especificada e retorna um ponteiro para a primeira posição
                        dessa memória alocada. <br>

                        <b>Construtores e Destrutores:</b> <br>
                        new chama o construtor do objeto, e delete chama o destrutor quando a memória é liberada.
                        malloc e free em C não têm conhecimento sobre construtores e destrutores de classes em C++. <br>

                        <b>Sintaxe:</b> <br>

                        A sintaxe para new é mais limpa e integrada à linguagem: <br>
                    </font>
                </p>

                <h3> 12 Como liberar a memória alocada dinamicamente?</h3>
                <p>
                    <font color="gray">
                        <p>
                            R: A liberação de memória alocada dinamicamente é uma prática essencial para evitar
                            vazamentos de memória. A forma de liberar a memória depende da maneira como ela foi alocada.
                            Aqui
                            estão as principais maneiras de liberar memória alocada dinamicamente em C++: <br> <br>


                            <b>Operador delete (para alocação com new):</b> <br> <br>

                        <p>
                            Quando você usa new para alocar memória para um único objeto ou um array, você deve usar
                            delete
                            ou
                            delete[] correspondente para liberar essa memória. <br>Ex:<br><br>
                        </p>

                        // Alocação de um único objeto com new <br>
                        int *ponteiroSimples = new int; <br><br>

                        // Liberação de memória com delete <br>
                        delete ponteiroSimples; <br>
                        <br><br>

                        // Alocação de um array com new[] <br>
                        int *arrayDinamico = new int[10]; <br><br>

                        // Liberação de memória do array com delete[] <br>
                        delete[] arrayDinamico; <br><br>

                        <b>Operador delete em Ponteiros Nulos:</b>
                        <p>
                            É seguro usar delete ou delete[] em um ponteiro nulo (que foi inicializado com nullptr ou
                            NULL).
                            Isso evita erros ao tentar liberar memória que não foi alocada. <br><br>
                            int *ponteiroNulo = nullptr;<br><br>

                            // Liberação de memória segura mesmo se o ponteiro for nulo br
                            delete ponteiroNulo; <br>

                        </p>
                        <b>Liberação Automática de Objetos Locais:</b>
                        <p>
                            Se você alocar objetos dinâmicos como membros de uma classe, a memória será liberada
                            automaticamente quando o objeto for destruído. Isso é conhecido como "liberação automática".
                        </p>
                </p>
                <pre>
                            <code>
                                class MinhaClasse {
                                    public:
                                        MinhaClasse() : ponteiroDinamico(new int) {}
                                    
                                        ~MinhaClasse() {
                                            // A memória será liberada automaticamente quando MinhaClasse for destruída
                                            delete ponteiroDinamico;
                                        }
                                    
                                    private:
                                        int *ponteiroDinamico;
                                    };
                                    
                            </code>
                        </pre>
                </p>
                <p>
                    É crucial garantir que a memória seja liberada adequadamente para evitar vazamentos. O não
                    cumprimento dessa prática pode levar a problemas sérios de gerenciamento de memória. O uso de
                    smart pointers, quando apropriado, pode ajudar a simplificar o gerenciamento de memória e
                    prevenir vazamentos.
                </p>

                </font>
                </p>
                <h3>13 O que são referências em relação a ponteiros?</h3>
                <p>
                    Em C++, referências e ponteiros são ambos usados para criar aliases (nomes alternativos) para
                    variáveis, mas existem diferenças fundamentais entre eles. Aqui estão algumas distinções
                    importantes:
                    <br><br>
                    <b>Uma referência é declarada usando o símbolo & no momento da declaração:</b> <br>
                    Ex: <br>
                <pre>
                        <code>
                            int x = 42;
                            int &refX = x;  // refX é uma referência para x
                        </code>
                </pre>

                <br>
                <b>Um ponteiro é declarado usando o símbolo * no momento da declaração:</b> <br>
                Ex: <br>
                <pre>
                        <code>  
                            int y = 24;
                            int *ponteiroY = &#38; y;  // ponteiroY é um ponteiro para y
                        </code>
                    </pre>

                </p>
                <p>
                    IMPORTANTE! Uma <em>referência</em> deve ser inicializada no momento da declaração e sempre se
                    refere ao mesmo objeto durante sua vida útil.
                    Diferente do ponteiro, que poder apntar para diferentes objetos do programa. Abiaxo terá um programa
                    exemplo e vamos estudar um
                    pouco sobre ele.
                </p>
                <pre>
                    <code>
4 #include <iostream></iostream>       
5 using namespace std;       
6 //========================================
7 //--Corpo do programa--
8 int main()
 {
10   cout &lt;&lt; "Hello REAA" &lt;&lt; endl;
11   cout &lt;&lt; "===Referência==========" &lt;&lt; endl;
12   int a=10;
13   int b=90;
14   int &aref=a;
15   cout &lt;&lt; "aref: " &lt;&lt; aref &lt;&lt; endl; //aref tem referência de 'a', então aref é exatamente o próprio 'a'. Logo aref é 10
16   cout &lt;&lt; "a: " &lt;&lt; a &lt;&lt; endl;  //valor de 'a'
17   aref=b; //Como, uma vez referenciado, sempre terá a mesma referência. 
             //Logo, como aref é 'a', atribuindo b em aref, logo 'a' tem o valor de b
18   cout &lt;&lt; "a eh alterado para valor de b: " &lt;&lt; a &lt;&lt; endl;
19        
20   cout &lt;&lt; "===Ponteiros==========" &lt;&lt; endl;
21   int *yptr, y=100, x=200;
22   yptr= &#38;y;
23   cout &lt;&lt; "(Valor de y)Yptr: " &lt;&lt; *yptr &lt;&lt; endl;
24   yptr = &#38;x;
25   cout &lt;&lt; "(Valor de x)Yptr: " &lt;&lt; *yptr &lt;&lt; endl;
26   cout &lt;&lt; "Valor de y:" &lt;&lt; y &lt;&lt; endl;
27   cout &lt;&lt; "Valor de x:" &lt;&lt; x &lt;&lt; endl;
28        
29        
30   return 0;
31   }//Fim
                    </code>
                </pre>
                <p>
                    A partir da linha 11 até a linha 19, escrevi algumas linhas de programa para demostrar didáticamente
                    o uso
                    da referência(&). A partir da linha 20 á linha 29, eu mostro o que acontece com o mesmo uso de
                    referência porém
                    usando ponteiros.
                </p>
                <p>
                    Primeiro defini duas variaveis inteiras, a e b com respectivos valores 10 e 90. Na Linha 14,
                    declarei uma variável de referência
                    para a variável 'a' seguida com o símbolo &(e-comercial) chamada <em>"&aref"</em>. <br> Na linha 15,
                    mostro que a variável de referência
                    se refere a variável 'a'. Na linha 16, mostro se o valor de 'a' ainda é o mesmo.
                    <br> Na linha 17, faço uma atribuição do valor de 'b' para a variável de referência
                    <em>"aref=b"</em>, e ai vem a grande sacada,
                    quando se usa variável de referência, ela será referência daquela variável em todo o programa, por
                    isso, o valor de 'a' está sendo alterado
                    para o valor de 'b'. E isso é mostrado na linha 18, esse é um exercício muito bom e legal pra
                    repetir e fazer mutios teste.
                </p>
                <p>
                    Depois desse entendimento, partimos a fazer o mesmo, porém com ponteiros. Na linha 21, eu declarei
                    um ponteiro e duas variáveis, todas
                    do tipo inteiro, pois se quero apontar para uma variável, o meu ponteiro precisa ser do mesmo tipo.
                    <br>
                    Atribuí a <em>y</em> e <em>x</em>, valores 100 e 200 e na linha 22 atribuo o endereço de <em>y</em>
                    para a variável ponteiro <em>yptr</em>.
                    e na linha 23 mostro que o ponteiro está de fato apontando para <em>y</em>. <br>
                    Na linha 24, atribuo o endereço da variável <em>x</em> ao mesmo ponteiro e mostro na linha 25, que
                    de fato está apontando para onde <em>x</em> está, no caso estou apenas pegando o valor para mostrar
                    no console.
                    <br>
                    E para entender bem a diferença entre os dois (referência e ponteiro), as linhas 26 e 27 mostram que
                    os respectivos valores de x e y não foram alterados com toda essa brincadeira.
                </p>
                <p>Para fazer alterações de valores de variáveis usando um único ponteiro, segue a sintaxe a baixo</p>
                <pre>
                    <code>
                        //para mudar o valor das variáveis através de ponteiros.
                        yptr= &#38;y;
                        *yptr=22;
                        yptr=&#38;x;
                        *yptr=94;

                        cout&lt;&lt;"(Apos alteracao)Valor de y:" &lt;&lt; y &lt;&lt; endl;
                        cout&lt;&lt;"(Apos alteracao)Valor de x:" &lt;&lt; x &lt;&lt; endl;
                    </code>
                   </pre>





                <h3>14 Como os ponteiros são utilizados em estruturas de dados?</h3>
                <p>
                    Os ponteiros são amplamente utilizados em estruturas de dados em C++ para criar estruturas dinâmicas
                    e permitir a manipulação eficiente de dados. Aqui estão algumas maneiras comuns de como os ponteiros
                    são empregados em estruturas de dados:
                </p>
                <b>Listas Encadeadas:</b>
                <p>
                    Em uma lista encadeada, cada elemento (nó) possui um ponteiro para o próximo elemento na sequência.
                    Isso permite a construção de listas de tamanho dinâmico, onde os elementos podem ser alocados e
                    desalocados conforme necessário.
                    A alocação dinâmica de nós permite uma economia de memória, pois os elementos podem ser alocados
                    conforme necessário.
                </p>
                <pre>
                    <code>
                        struct No
                        {
                            int dado;
                            No *proximo;  // Ponteiro para o próximo nó na lista
                        };
                        
                    </code>
                </pre>
                <b> Árvores:</b>
                <p>
                    Em árvores binárias ou em outras formas de árvores, cada nó geralmente tem ponteiros para seus
                    filhos (e, possivelmente, para o pai).
                    Isso permite estruturas hierárquicas eficientes, como árvores de busca binária ou árvores de
                    expressão.
                </p>
                <pre>
                    <code>
                        struct NoArvore 
                        {
                            int dado;
                            NoArvore *esquerda;
                            NoArvore *direita;
                        };                        
                    </code>
                </pre>
                <b> Grafos:</b>

                <p>
                    Em estruturas de dados de grafo, os ponteiros são frequentemente usados para representar conexões
                    entre vértices.
                    Um vértice pode ter ponteiros para outros vértices aos quais está conectado.
                </p>
                <pre>
                    <code>
                            struct Vertice
                            {
                                int dado;
                                std::vector<Vertice*> vizinhos;  // Ponteiros para vértices vizinhos
                            };        

                        </code>
                    </pre>

                <b>Listas Duplamente Encadeadas:</b>

                <p>
                    Semelhante a listas encadeadas, mas cada nó possui ponteiros para o próximo e para o anterior na
                    sequência.
                    Isso permite iteração bidirecional na lista.
                </p>
                <pre>
                        <code>
                            struct NoDuplo 
                            {
                                int dado;
                                NoDuplo *proximo;
                                NoDuplo *anterior;
                            };
            
                        </code>
                </pre>
                <b> Filas e Pilhas Dinâmicas:</b>

                <p>
                    Em filas e pilhas, os ponteiros são frequentemente usados para manter o controle do início e do fim
                    da estrutura.
                    Isso permite a adição eficiente de elementos (enfileiramento ou empilhamento) e a remoção eficiente
                    (desenfileiramento ou desempilhamento).
                </p>
                <pre>
                        <code>
                            struct NoFila {
                                int dado;
                                NoFila *proximo;
                            };
                            
                            struct Fila {
                                NoFila *inicio;
                                NoFila *fim;
                            };
                            
                    </code>

                </pre>
                <p>
                    Esses são apenas alguns exemplos de como os ponteiros são fundamentais para a implementação
                    eficiente de diversas estruturas de dados em C++. O uso adequado de ponteiros permite criar
                    estruturas dinâmicas, economizando memória e possibilitando operações eficientes de inserção,
                    remoção e manipulação de dados. No entanto, é importante ter cuidado ao gerenciar a alocação e
                    desalocação de memória para evitar vazamentos ou acesso indevido à memória.
                </p>
                <h3>15 O que é polimorfismo de ponteiro?</h3>
                <p>
                    O polimorfismo de ponteiro em C++ refere-se à capacidade de um ponteiro para uma classe base apontar
                    para objetos de classes derivadas e invocar métodos específicos da classe derivada durante a
                    execução. Essa funcionalidade é uma parte crucial da programação orientada a objetos e é uma das
                    características-chave que permite o desenvolvimento de código flexível e genérico.
                </p>
                <p>
                    O polimorfismo de ponteiro é alcançado por meio do uso de ponteiros para classes base e a presença
                    de funções virtuais na classe base, que podem ser sobrescritas nas classes derivadas. Aqui estão os
                    elementos-chave que contribuem para o polimorfismo de ponteiro:
                </p>
                <b>Funções Virtuais:</b>
                <p>
                    Uma função virtual é declarada na classe base usando a palavra-chave virtual.
                    As classes derivadas podem sobrescrever a função virtual usando a palavra-chave override.
                    A função virtual na classe base é chamada de função base.
                </p>
                <b>Ponteiro para Classe Base:</b>
                <p>
                    Você pode criar um ponteiro para a classe base e atribuir a ele objetos das classes derivadas.
                    O polimorfismo ocorre quando você chama uma função virtual usando esse ponteiro.
                </p>
                <pre>
                    <code>
                        int main() {
                            Animal *ponteiroAnimal;
                        
                            Cachorro meuCachorro;
                            Gato meuGato;
                        
                            ponteiroAnimal = &#38;meuCachorro;
                            ponteiroAnimal->fazerSom();  // Chama a função virtual sobrescrita em Cachorro
                        
                            ponteiroAnimal = &#38meuGato;
                            ponteiroAnimal->fazerSom();  // Chama a função virtual sobrescrita em Gato
                        
                            return 0;
                        }
                        
                    </code>
                </pre>
                <p>
                    Neste exemplo, o mesmo ponteiro (ponteiroAnimal) é usado para apontar para objetos de diferentes
                    classes derivadas, e a função virtual fazerSom() é chamada através desse ponteiro. Isso demonstra o
                    polimorfismo de ponteiro, onde o comportamento específico da classe derivada é invocado, dependendo
                    do tipo real do objeto para o qual o ponteiro aponta.                    
                </p>
                <p>
                    O polimorfismo de ponteiro é uma parte fundamental da herança e da programação orientada a objetos,
                    permitindo que o código trabalhe com objetos de classes derivadas de maneira genérica e flexível.
                    Isso contribui para a reutilização de código e a criação de hierarquias de classes mais extensíveis.
                </p>

                </p>
                <p>
                    Essas perguntas ajudarão a construir uma compreensão mais abrangente dos conceitos de ponteiros e
                    endereços na linguagem de programação C++. A leitura do cáptulo 8 do livro "Como programar C++-Deitel,5ed" é imprescindivel para um melhor
                    aprendizado.
                </p>
            </div>
        </section>

        <!--Rodapé-->
        <footer id="rodape">
            <p>
                by Lucas Lorenço Alves | senoratec.io@gmail.com |
                <a href="https://www.linkedin.com/in/lucas-lorenço-alves-4206b9201/" target="_blank">linkedin</a>
            </p>
        </footer>

    </div>
</body>

</html>



<!--Fazendo um adendo nesse paragráfo,
                   em muitos livros você não vai encontrar uma explicação como essa, pois <em>variável ponteiro</em> é apenas chamada de ponteiro, e que ela 
                   armazena endereço de mémória, formalmente está corretissímo, mas causa um bug na cabeça. O bom de se pensar é que ponteiro é como um car-->